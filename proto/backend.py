from io import TextIOWrapper
from typing import Callable, Optional
from .compiler import Compiler, SeaFunction, SeaRecord, SeaTag, SeaType
from .syntax.Parser import Parser

# TODO: Reorganize functions
class Backend:
	def __init__(self, compiler: Compiler, output_file: str):
		self.compiler = compiler
		self.output_file = output_file
		self.libpaths = ['.']
		self.line_ending = '\n'
		self.depth = 0
		self.indent = '\t'
		self.block_needs_line_ending = False
		self.force_indent_next = False
		self.module = None
		self.using = []
		self.module_stack = []
		self.file: TextIOWrapper

	def __enter__(self):
		self.file = open(self.output_file, 'w')
		return self

	def __exit__(self, _a, _b, _c):
		self.file.close()

	def needs_line_ending(self, stat: Parser.StatContext):
		return not (
			stat.stat_for() is not None or
			stat.stat_each() is not None or
			stat.stat_if() is not None or
			stat.stat_else() is not None or
			stat.expr_block() is not None
		)

	def write(self, text: str, indent: bool = True):
		if indent or self.force_indent_next:
			self.file.write(self.indent * self.depth)
			if self.force_indent_next:
				self.force_indent_next = False
		self.file.write(text)

	def writeln(self, text: str, indent: bool = True):
		if indent or self.force_indent_next:
			self.file.write(self.indent * self.depth)
			if self.force_indent_next:
				self.force_indent_next = False
		self.file.write(text)
		self.file.write('\n')

	def type(self, type: SeaType) -> str: ...
	def typed_id(self, type: SeaType, id: str) -> str: ...

	def file_begin(self): ...
	def file_end(self): ...

	def use(self, module: str): ...
	def rec(self, name: str, record: SeaRecord): ...
	def fun_begin(self, name: str, func: SeaFunction): ...
	def fun_end(self): ...
	def def_(self, name: str, type: SeaType): ...
	def tag(self, name: str, tag: SeaTag): ...
	def tagrec_tag(self, name: str, fields: list[str]): ...
	def tagrec_rec(self, name: str, fields: dict[str, SeaRecord], kind_name: Optional[str] = None): ...
	def tagrec(self, name: str, fields: dict[str, SeaRecord]): ...

	def var(self, name: str, type: SeaType, value: Callable, is_top_level: bool = False): ...
	def let(self, name: str, type: SeaType, value: Callable, is_top_level: bool = False): ...
	def assign(self, name: Callable, value: Callable): ...
	def ret(self, value: Optional[Callable]): ...

	def block_begin(self): ...
	def block_end(self): ...
	def invoke(self, id: str, args: list[Callable]): ...
	def if_(self, cond: Callable): ...
	def else_(self): ...
	def for_c_style(self, define: Callable, cond: Callable, inc: Callable): ...
	def for_single_expr(self, cond: Callable): ...
	def for_to(self, var: Optional[str], from_: Callable, to: Callable): ...
	def each_begin(self, var: str, of: str): ...
	def each_end(self): ...
	def switch_begin(self, of: Callable): ...
	def switch_end(self): ...
	def case(self, match: Callable): ...
	def case_else(self): ...
	def case_break(self): ...

	def true(self): ...
	def false(self): ...

	def dot(self, left: Callable, right: Callable): ...
	def not_(self, value: Callable): ...
	def and_(self, left: Callable, right: Callable): ...
	def or_(self, left: Callable, right: Callable): ...
	def eq(self, left: Callable, right: Callable): ...
	def neq(self, left: Callable, right: Callable): ...
	def gt(self, left: Callable, right: Callable): ...
	def gteq(self, left: Callable, right: Callable): ...
	def lt(self, left: Callable, right: Callable): ...
	def lteq(self, left: Callable, right: Callable): ...
	def inc(self, value: Callable): ...
	def dec(self, value: Callable): ...

	def add(self, left: Callable, right: Callable): ...
	def sub(self, left: Callable, right: Callable): ...
	def mul(self, left: Callable, right: Callable): ...
	def div(self, left: Callable, right: Callable): ...
	def mod(self, left: Callable, right: Callable): ...

	def group_expr(self, it: Callable): ...
	def number(self, it: str): ...
	def id(self, it: str): ...
	def string(self, it: str, c: bool): ...
	def char(self, it: str): ...
	def array(self, type: Optional[SeaType], items: list[Callable]): ...
	def new(self, rec: str, items: list[Callable]): ...
	def ref(self, value: Callable): ...
	def deref(self, value: Callable): ...
	def cast(self, type: SeaType, value: Callable): ...
	def index(self, expr: Callable, index: Callable): ...

	def raw(self, code: str): ...
