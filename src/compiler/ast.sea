use std/result
use std/ds/dynarr

gen Maybe{SeaType}
gen DynamicArray{ASTNode}

// forward declare ASTNode
//TODO: automatically do forward-declarations
raw[
	struct ASTNode;
	typedef struct ASTNode ASTNode;
]

tag BinaryExprKind(
	// Boolean ops
	BIN_EXPR_AND,
	BIN_EXPR_OR,
	// Comparisons
	BIN_EXPR_EQ,
	BIN_EXPR_NEQ,
	BIN_EXPR_GT,
	BIN_EXPR_GTEQ,
	BIN_EXPR_LT,
	BIN_EXPR_LTEQ,
	// Math
	BIN_EXPR_ADD,
	BIN_EXPR_SUB,
	BIN_EXPR_MUL,
	BIN_EXPR_DIV,
	BIN_EXPR_MOD,
)

// Expressions
rec $NodeBinaryExpr(left: ASTNode, right: ASTNode, op: BinaryExprKind)
rec $NodeInvoke(id: String, params: DynamicArray{ASTNode})
// Expressions - Literals
rec $NodeNumber(value: String) // value is just written directly to C anyway, so we don't really care what it is.
rec $NodeString(value: String)
rec $NodeChar(value: char)
rec $NodeBool(value: bool)
rec $NodeID(name: String)

// Statements
rec $NodeVar(name: String, type: Maybe{SeaType}, value: ASTNode)
rec $NodeLet(name: String, type: Maybe{SeaType}, value: ASTNode)
// Statements - Top-level-only
rec $NodeUse(path: DynamicArray{String})
rec $NodeFun(hashtags: DynamicArray{String}, name: String, param_count: int, params: ^SeaType, returns: SeaType, code: ^SeaAST)
rec $NodeRec(hashtags: DynamicArray{String}, name: String, field_count: int, field_names: ^String, field_types: ^SeaType)

// "tagged pointer"
tag rec ASTNode(
	// Expressions
	NodeBinaryExpr(it: ^$NodeBinaryExpr)
	NodeInvoke(it: ^$NodeInvoke)
	// Expressions - Literals
	NodeNumber(it: ^$NodeNumber)
	NodeString(it: ^$NodeString)
	NodeChar(it: ^$NodeChar)
	NodeBool(it: ^$NodeBool)
	NodeID(it: ^$NodeID)

	// Statements
	NodeVar(it: ^$NodeVar)
	NodeLet(it: ^$NodeLet)
	// Statements - Top-level-only
	NodeUse(it: ^$NodeUse)
	NodeFun(it: ^$NodeFun)
	NodeRec(it: ^$NodeRec)
)
